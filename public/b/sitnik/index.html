<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="initial-scale=1.0, user-scalable=no"><meta name="description" content="Code Hipsters — сообщество программистов и цифровых дизайнеров из Ростова-на-Дону"><meta name="keywords" contet="code hipsters,кодохипстеры,код хипстеры,сообщество в ростове,ит-сообщество,митапы,смузи,братишки,фикус"><title>Андрей Ситник: «Будущее за CSS постпроцессорами!» · Code Hipsters</title><!-- WARNING: for iOS 7, remove the width=device-width and height=device-height--><!-- attributes. See https://issues.apache.org/jira/browse/CB-4323--><meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi"><link href="https://fonts.googleapis.com/css?family=Rubik:300,300i,400,400i,500,500i,700,700i" rel="stylesheet"><link rel="stylesheet" href="/app.css"><script src="/app.js"></script><script>require('initialize');
</script></head><body class="site"><div class="banner"><div class="banner__image banner__image--first"></div><div class="banner__image banner__image--second"></div><div class="banner__content"><div class="banner__logo-wrap"><img class="banner__logo" src="/images/ch-horiz-white.svg"></div><div class="banner__slogan">Постмодерн умер, а веб — еще нет</div></div></div><div class="post"><header class="post__header"><h1 class="post__title">Андрей Ситник: «Будущее за CSS постпроцессорами!»</h1><div class="post__meta"><div class="post__author">Витя Суздалев · 27 ноября 2014</div></div></header><article class="post__content"><p>Всем привет! Редакция <a href="https://vk.com/codehipsters">Code Hipsters</a> поговорила с фронтендером <a href="https://evilmartians.com/">Evil Martians</a> и автором <a href="https://github.com/postCSS/postCSS">PostCSS</a> <a href="http://sitnik.ru/">Андреем Ситником</a> о пре- и пост-процессинге CSS, трендах фронтент-разработки и планах на будущее.</p>
<p><strong>Code Hipsters:</strong> Добрый день, Андрей! Если коротко, то зачем пересобирать CSS-ки? Все же давно и надолго радуются Sass и Less.</p>
<p><strong>Андрей Ситник:</strong> Кому нужна пост-обработка — формально всем фронтенд-разработчикам. PostCSS служит как замена Sass, LESS, Stylus. Кроме этого он нужен для линтеров, минификаторов, плагинов для редакторов. В общем, если тебе нужно как-то изменить CSS, то проще всего это сделать через PostCSS, так как он даст тебе карты кода, API, и парсер. Теперь вопрос, чем лучше Sass и т.д. Собственно, первую идею постпроцессора предложил TJ и сделал свой Rework, вот <a href="http://tjholowaychuk.tumblr.com/post/44267035203/modu">тут он пишет зачем</a>. Если вкратце: препроцессоры сложные и медленные и дают мало функций. Теперь подробнее. Сложные, потому что они монолитные. Есть только один тип переменных, встроенный в язык. Есть парсер особого языка программирования прямо в CSS,
всё это усложняет разработку препроцессоров. Очень мало кто коммитил в Sass, потому что это трудно. PostCSS — это просто парсер и стрингифаер. Все функции (переменные, примеси, префиксы) — это подключаемые JS-модули. Много кто разрабатывает такие плагины, потому что это очень просто.</p>
<p><img src="/images/sitnik-cite-2.jpg" alt=""></p>
<p>Во-вторых, PostCSS не имет какого-то языка программирования внутри CSS. Вся магия (например, разворачивание префиксов) написана в JS-коде. В плагине Автопрефиксер нет <code>@if</code>, <code>@for</code> и т.п. Можно написать плагин, который будет это добавлять, но тьюринг-полного языка конструкций нет и вряд ли будет, так как проще написать узкозаточенный под бизнес-логику плагин на JS, чем писать вычисления «на Sass». Одна из реализаций переменных <a href="https://github.com/postCSS/postCSS-custom-properties">предложена здесь</a> (это на самом деле полифил к новой спеке CSS-переменных).</p>
<p><strong>Code Hipsters:</strong> А как мы получаем переменные и прочие миксины? То есть как это делается с предобработкой мне понятно — вот текст, вот парсер, перевели — и молодцы. Верно ли, что мы скармливаем постпроцессору произвольный текст, а перевод делают JS-модули?</p>
<p><strong>Андрей Ситник:</strong> Поскольку там есть конкретный парсер, то текст должен быть похож на CSS.</p>
<p><strong>Code Hipsters:</strong> Ок, про произвольный я специально перегнул.</p>
<p><strong>Андрей Ситник:</strong> Угу, но да, он может быть расширен какими-то кастомными конструкциями в широких пределах, а какой-то конкретный плагин будет эти конструкции ловить. Можно написать поддержку <code>@if</code>, например: достаточно в плагине найти все <code>at-rule</code> с <code>name == &quot;if&quot;</code> и что-то сделать с их телом.</p>
<p><strong>Code Hipsters:</strong> А если несколько плагинов одни <code>at-rule</code> ловят? Насколько большие проблемы доставляет такой произвол?</p>
<p><strong>Андрей Ситник:</strong> Тут вопрос в порядке подключения плагинов: например, переменные желательно подключать до <code>calc()</code>.</p>
<p><strong>Code Hipsters:</strong> А тестировать это как-то можно?</p>
<p><strong>Андрей Ситник:</strong> Пока баг-репрортов с коллизиями не было, так что такой вопрос не поднимался; обычно плагинов до 10.</p>
<p><strong>Code Hipsters:</strong> А сколько всего успели написать? И много ли ребят кроме тебя этим занимаются?</p>
<p><strong>Андрей Ситник:</strong> Практически все плагины перечислены <a href="https://github.com/postCSS/postCSS">тут</a>. В основном работают 2 француза, один японец, necolas из Твиттера. Француз, например, написал <a href="https://cssnext.github.io/cssnext-playground/">cssnext-playground</a>, японец написал <a href="https://github.com/hail2u/node-csswring">минификатор</a> - один из немногих кто держит карты кода, Николас <a href="(https://github.com/necolas/postCSS-bem-linter">линтер</a>) написал, он сейчас переходит с Rework на PostCSS. В целом, Твиттер сейчас на постпроцессорах, правда, на Rework, он был первым.</p>
<p><strong>Code Hipsters:</strong> А ты насколько активно занимаешься проектом сейчас?</p>
<p><strong>Андрей Ситник:</strong> Я бы сказал, что моей компании очень не нравится, насколько активно я занимаюсь проектом, в том числе в рабочее время. Мы закончили пока с первым плюсом PostCSS — они легче в разработке, чем Sass; дальше — скорость. Из-за монолитности и поддержки тьюринг-полного языка в Sass они очень медленные, Ruby Sass непозволительно медленный. Libsass решает проблему, но урезает функционал (нельзя подключать Ruby-расширения), в итоге спрайты и инлайн картинок уже нормально не сделать. Stylus быстрее, но не сильно. Из-за простоты постпроцессоры очень быстрые. По бенчмаркам cssnext на PostCSS в 3 раза быстрее libsass и в 30 раз быстрее Ruby Sass (<a href="https://github.com/postcss/postcss/issues/64#issuecomment-64196062">бенчмарк</a>).</p>
<p><strong>Code Hipsters:</strong> Именно за счет другой модели работы, верно?</p>
<p><strong>Андрей Ситник:</strong> Ага. Просто парсер и пару JS-функций, бегающих по дереву. Конечно всё ещё зависит от того, насколько сложные эти функции, но сейчас все они быстрее Stylus точно.
Кстати, покажу ещё <a href="https://github.com/iamvdo/pleeease-filters">крутой процессор</a> — полифил для <code>filter: blur(2px)</code> и т. п.</p>
<p>Ну и третий плюс — возможности.</p>
<p><strong>Code Hipsters:</strong> К слову, а почему <em>пост-</em>?</p>
<p><strong>Андрей Ситник:</strong> Вот тут большая непонятка, я так и не понял, откуда появилось это слово. Думал его придумал TJ, но оказалось, что он его не упоминал. Главная идея названия в том, что постпроцессоры работают уже с CSS, хотя иногда это нарушается.</p>
<p><strong>Code Hipsters:</strong> Но это же не CSS! Я запутался.</p>
<p><strong>Андрей Ситник:</strong> Есть проблема с названием, я бы сказал что оно историческое.</p>
<p><strong>Code Hipsters:</strong> Понял.</p>
<p><img src="/images/sitnik-cite-4.jpg" alt=""></p>
<p><strong>Андрей Ситник:</strong> Третий плюс про мощность. Проблема Sass в том, что всю магию можно сделать только на примесях, переменных или функциях. Единственный способ сделать префиксы — добавить свою библиотеку примесей. Но что если я не хочу помнить о том, где нужно использовать примесь, а где нет? У Автопрефиксера очень крутой UI — ты просто забываешь о префиксах, такого UI нельзя сделать в препроцессорах. То же самое с полифилами — хочется, чтобы они просто «магически» работали.</p>
<p><strong>Code Hipsters:</strong> Потому что препроцессоры толком нельзя расширять? Из-за сложного ядра?</p>
<p><strong>Андрей Ситник:</strong> Я бы сказал, ограничение в самой идеи. Sass — это примеси, переменные и функции, сама идея не позволяет свободно ходить по AST.</p>
<p><strong>Code Hipsters:</strong> По факту, один из основных плюсов PostCSS — это контроль и маленькие обработчики для конкретных задач?</p>
<p><strong>Андрей Ситник:</strong> Ну и гибкость.</p>
<p><strong>Code Hipsters:</strong> Такие Web Components для CSS.</p>
<p><strong>Андрей Ситник:</strong> Я бы сказал, компоненты для процессинга CSS. Но да, ты собираешь свою обработку из кирпичиков, кирпичики простые, могут делать что угодно и быстрые. Вот ещё пример, что нельзя сделать на примесях или функциях: <a href="https://github.com/robwierzbowski/node-pixrem">полифил для rem</a>. Или <a href="https://github.com/Sebastian-Fitzner/grunt-data-separ">плагин</a>, который выносит все заинлайненные картинки в отдельный файл (чтобы стили грузились в два этапа). Полифилов очень много, я хочу выходить из гнёта спек и делать какие-то новые вещи. Например, реализовать переменные как в Sass, так как они удобнее спеки.</p>
<p><strong>Code Hipsters:</strong> JavaScript пытаются починить куча людей, насобирали языков и линтеров, все никак не починят, как многим кажется.</p>
<p><strong>Андрей Ситник:</strong> JavaScript ужасный язык, на котором мы вынуждены программировать.</p>
<p><strong>Code Hipsters:</strong> А зачем столько сил тратить на CSS?</p>
<p><strong>Андрей Ситник:</strong> Потому что CSS кода больше.</p>
<p><strong>Code Hipsters:</strong> То есть на него сильно сложные задачи ложатся? Но он же простой?</p>
<p><img src="/images/sitnik-cite-1.jpg" alt=""></p>
<p><strong>Андрей Ситник:</strong> В проекте CSS кода может быть больше чем всего остального, когда его очень много, он не поддерживаемый. Поэтому мы меняем простоту на сокращение размера и увеличение поддерживаемости.</p>
<p><strong>Code Hipsters:</strong> Так и less такой же не поддерживаемый.</p>
<p><strong>Андрей Ситник:</strong> Ну не совсем, переменные и примеси уже позволили сделать его лучше, например хаки вынести. То есть ты пишешь не 5—6 правил, тут же забывая, зачем они,
а пишешь <code>+clearfix</code>. Кстати, много логики из JS начинает идти в CSS, например анимации; я вообще стараюсь в JS только классы менять, а все анимации и внешний вид состояний описывать в CSS.</p>
<p><strong>Code Hipsters:</strong> А как насчет стилизации без классов, насколько это реально? Я недавно на <a href="http://alistapart.com/article/axiomatic-CSS-and-lobotomized-owls">статью</a> о селекторе «лоботомированная сова» наткнулся, писали о нем где-то неделю назад.</p>
<p><strong>Андрей Ситник:</strong> Есть ещё другая идея — инлайн всех стилей в теги, ReactStyle этим занимается.</p>
<p><strong>Code Hipsters:</strong> Зачем? Т.е. один запрос а не два, быстрее обработка, потому что все уже инлайн?</p>
<p><strong>Андрей Ситник:</strong> Ну это ребята из React угорают.</p>
<p><strong>Code Hipsters:</strong> Но это же плохо?</p>
<p><strong>Андрей Ситник:</strong> Но там есть интересные идеи, пока рано рассматривать серьёзно и надо смотреть на время рендера. Ну в общем CSS так же активно развивается, так как это такой же код, как и JS, пусть и не алгоритм. Нам всё равно надо его красиво организовывать и иметь инструменты.</p>
<p><strong>Code Hipsters:</strong> Резюмируя, процессинг нужен, потому что язык не позволяет писать поддерживаемый код, плюс, очень много всего уходит из ведения jQuery-animation в CSS.</p>
<p><strong>Андрей Ситник:</strong> Я бы сказал, что переход jQuery-анимаций в CSS сразу же сокращает код. Анимациям не место в JS идеологически, отсюда получаем практические проблемы: падение скорости, смесь представления и логики и т.п. Кстати, пока PostCSS-плагинов для анимаций не было, а жаль. Надо, наверное, написать чистилку CSS-анимаций, которых никто не будет использовать.</p>
<p><strong>Code Hipsters:</strong> А <a href="https://github.com/giakki/uncss">unCSS</a> этого не делает?</p>
<p><strong>Андрей Ситник:</strong> Может и делает, но unCSS сложно подключить во многие проекты, где нельзя быстро получить весь возможный HTML, а с анимациями мы знаем точно, если договорились не менять стили руками из JS. Так что unCSS мы пока не используем. Мне кажется, эту проблему лучше решать компонентным подходом, чтобы JS, шаблон и CSS лежали в одной папке — удалил компонент, удалил и стили.</p>
<p><strong>Code Hipsters:</strong> А React?</p>
<p><strong>Андрей Ситник:</strong> А что с React?</p>
<p><strong>Code Hipsters:</strong> Вьюхи в непонятном формате, и из них разметка по волшебству получается.</p>
<p><strong>Андрей Ситник:</strong> Есть у меня одна идейка — взять <a href="https://github.com/ai/file-container">это</a> и объединить с react-haml. Но пока ещё только в формате идеи.</p>
<p><strong>Code Hipsters:</strong> К слову, раз речь зашла. Как ты думаешь, почему по React-у все так угорели?</p>
<p><strong>Андрей Ситник:</strong></p>
<ol>
<li>Он очень быстро рендерит.</li>
<li>Он решает многие проблемы 2-way data binding с помощью реактивного подхода. Если мне нужно будет делать SPA (я правда считаю, что большинству проектов SPA не нужен), то я буду делать на React-е.</li>
</ol>
<p><strong>Code Hipsters:</strong> Так сейчас каждый первый фреймворк реактивный.</p>
<p><strong>Андрей Ситник:</strong> Ну Ember и Angular вроде ещё нет.</p>
<p><strong>Code Hipsters:</strong> К слову, Ember обещают впилить react-way рендеринг ко второй версии, т.е., довольно скоро.</p>
<p>Так Angular все сам обновляет, по сути, как я понимаю, та же реактивность. По крайней мере в том смысле, что если поменять переменную, от которой зависит другая, то и последняя поменяется.</p>
<p><strong>Андрей Ситник:</strong> Ну до <a href="https://facebook.github.io/flux/">FLUX</a> им далеко в плане реактивности. То есть вся идея в том, что у нас есть модели, события, на выходе получаем JSON-состояния, и оно попадает в state-less вьюшки на React — она довольно сильная.</p>
<p><strong>Code Hipsters:</strong> Потому что с 2-way все намучались?</p>
<p><strong>Андрей Ситник:</strong> Именно, что React-компоненты без состояний. Я бы сказал, что есть сайд-эффекты. По фреймворкам лучше спроси Лёшу Плуталова (у нас в марсианах), он к курсу очень глубоко погрузился в каждый: Ember и Angular, я их знаю только поверхостно.</p>
<p><strong>Code Hipsters:</strong> Просто к слову пришлось, я поэтому спросил. Про React интересно, потому что, как говорил, мне пока непонятно, почему такой сильный хайп.</p>
<p><strong>Андрей Ситник:</strong> Простота — нет <code>$scope</code>, <code>watch</code>.</p>
<p><strong>Code Hipsters:</strong> И провайдеров для конфигурации сервисов, которые встраиваются в контроллеры директив. Видимо, даже отдельный формат для разметки после этого спагетти уже не пугает.
И отдельной сторокой, почему React от Facebook такой быстрый, а Facebook — нет?</p>
<p><strong>Андрей Ситник:</strong> Это хороший вопрос :D</p>
<p><strong>Code Hipsters:</strong> Про инструменты хотел спросить. По ссылкам, которые ты кидал, есть и grunt-, и gulp-плагины; есть ли у PostCSS «любимая» система сборки? Насколько сложно вообще встраивать обработчики в процесс подготовки проекта к деплою?</p>
<p><strong>Андрей Ситник:</strong> Я какое-то время увлекался <a href="http://webpack.github.io/">webpack</a>, так как он сейчас самый умный. Поэтому единственный плагин для поддержки PostCSS, что лежит в огранизации PostCSS — это postcss-loader для вебпака. Но последнее время я сильно расстроился из-за webpack. Параметры в плагины сложно передавать (только URL-строкой). Поэтому PostCSS-loader использует хак с паками. И Webpack ужасно работает с CSS.</p>
<p><strong>Code Hipsters:</strong> А как же grunt и gulp? Все с первого на второй только переезжают.</p>
<p><strong>Андрей Ситник:</strong> Не вижу причин пользоваться grunt. Вот как раз я лично сейчас больше всего люблю gulp, но мне не хватает двух функций из вебпака: сборка JS и CSS вместе по зависимостям, чтобы не указывать руками список файлов, а смотреть по <code>require()</code> в JS, и тут же хватать все стили, что лежат рядом с подключёнными JS-файлами.</p>
<p><strong>Code Hipsters:</strong> А <a href="http://browserify.org/">browserify</a>?</p>
<p><strong>Андрей Ситник:</strong> Ага, browserify + CSS-файлы, даже думаем с Шебановым написать свой плагин для gulp для этого, но задача сложная. Тем более хотелось бы сначала всё компилировать очень крутыми плагинами gulp, а потом собирать.</p>
<p><strong>Code Hipsters:</strong> А PostCSS не может сконкатенировать все в один, его подключили — и вперед?</p>
<p><strong>Андрей Ситник:</strong> Может, но всё в один не подходит для большинства проектов. Например есть отдельно стили для лэндинга, отдельно для главного сайта и отдельно для админки. У каждой этой точки входа есть своё дерево зависимостей.</p>
<p><strong>Code Hipsters:</strong> Так это разные подпроекты, которые, по идее, отдельно собираются?</p>
<p><strong>Андрей Ситник:</strong> У них часто есть общая кодовая база, кнопки, например, или попапы.</p>
<p><strong>Code Hipsters:</strong> Так получается какой-то common-styles, который подключается во все «подпроекты».</p>
<p><strong>Андрей Ситник:</strong> Ну вот не всегда во всех. Например, админка и главные стили делят попап между собой, а промо и главные стили — кнопки. Webpack уже решает эту проблему, он просто смотрит зависимости по <code>require()</code>. И Sprockets в рельсах так же — ты указываешь ему точку входа, он смотрит особые комментарии и подключает их
в Sprockets. В Webpack ты указываешь зависимости CSS в JS</p>
<pre><code>require(&#39;./style.css&#39;)
require(&#39;components/buttons.css&#39;)
</code></pre><p>Webpack тут лучше Sprockets, так как в Sprockets дерево зависимостей надо было дублировать в CSS и в JS, а в Webpack ты подключаешь «компонент» кнопки, а он уже сам подключает свои стили. Вот такую штуку хочется иметь в gulp, и чтобы ещё не переключаться между файлами использовать file-container.</p>
<p><strong>Code Hipsters:</strong> А чем это будет отличаться от компонента?</p>
<p><strong>Андрей Ситник:</strong> Web Components — это API изоляции в браузере, но да, идея общая. Скажем так — это компоненты для сборки.</p>
<p><strong>Code Hipsters:</strong> Не, я о Web Components. С их сборкой <a href="https://github.com/polymer/vulcanize">vulcanize</a> вроде помогает?</p>
<p><strong>Андрей Ситник:</strong> Тоже другой подход, но у него минус в том, что он привязан к компонентам, и его для React сложнее реализовать — или для сайта без рендера на клиенте. Webpack сейчас делает этот компонентый подход для любого фреймворка.</p>
<p><strong>Code Hipsters:</strong> Здорово!</p>
<p>Есть ли какая-то фронтенд-технология, которая тебя занимает больше остальных, если не говорить про PostCSS, конечно? Как тебе кажется, что из всего зоопарка будет мейнстримом через какое-то время?</p>
<p><img src="/images/sitnik-cite-3.jpg" alt=""></p>
<p><strong>Андрей Ситник:</strong> Меня интересует три вещи:</p>
<ul>
<li>сборка</li>
<li>CSS</li>
<li>анимации</li>
</ul>
<p>Компонентный подход явно станет мейнстримом, его давно уже внедрили в БЭМ-тулзах Яндексы. Webpack идёт туда, Web Components тоже. То есть главная идея будет в том, что мы будем разбивать интерфейс на маленькие части и хранить CSS, JS, шаблоны для этих частей вместе с одной папке.</p>
<p><strong>Code Hipsters:</strong> А ты пользуешься тулами яндекса?</p>
<p><strong>Андрей Ситник:</strong> Неа, они ад, но идеи там очень здравые.</p>
<p><strong>Code Hipsters:</strong> У нас чуваки оттуда делали два доклада на митапе полгода назад, всех запутали и напугали.</p>
<p><strong>Андрей Ситник:</strong> Ну это как раз пример того, как реализация убивает идею.</p>
<p><strong>Code Hipsters:</strong> Мне кажется, их как раз Web Components съедят — не говоря о реализации.</p>
<p><strong>Андрей Ситник:</strong> Web Components ещё долго ждать, <a href="https://www.polymer-project.org/">Polymer</a> не даёт никакой изоляции, так что изоляция — всё снова на БЭМ. Я боюсь, как бы инлайновые стили не выстрелили, тогда придётся заново изобретать CSS.</p>
<p><strong>Code Hipsters:</strong> Так какие-то тулы этим уже занимаются, ты говорил.</p>
<p><strong>Андрей Ситник:</strong> Ага, пока у них всё плохо.</p>
<p><strong>Code Hipsters:</strong> И в любом случае руками никто инлайнить не будет, так что не много меняется.</p>
<p><strong>Андрей Ситник:</strong>  Да, тут потребуется новое поколение инструментов, и всё это — <em>только</em> под клиентский рендеринг. Не понятно со скоростью рендера. Думаю не выстрелит, даже если окажется быстрее чем по селекторам.</p>
<p><strong>Code Hipsters:</strong> Спасибо огроменное за — ничего себе! — больше чем часовой разговор. Меня, например, в том, что за PostCSS будущее, ты полностью убедил. Было очень интересно!</p>
</article></div><!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter27264008 = new Ya.Metrika({
                    id:27264008,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/27264008" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
</body></html>